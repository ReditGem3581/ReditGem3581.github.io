---
layout: essay
type: essay
title: "Friction in Foundation"
# All dates must be YYYY-MM-DD format!
date: 2025-09-23
published: true
labels:
  - Coding
  - ESLint
  - Standards
---

# Friction in Foundation

## Coding Standards as the Groundwork

If code is a building, then coding standards are the foundation. Without a foundation, a building might stand for a little while, but it will collapse once people start adding weight to it. Software projects work the same way. The bigger the project, the more people touch it, and the more fragile it becomes without shared rules. To me, coding standards are not just “helpful”—they actually *define* the language. They give you something to hold on to, a grammar that makes sense of the syntax.

This is why I agree with the idea that coding standards are vital for software development. They’re not trivia about indentation or curly braces. They’re the structure that makes code reliable, shareable, and easier to learn.

## ESLint: Both Useful and Annoying

After a week with ESLint in VSCode, I have mixed feelings. On the one hand, it’s useful. When it works, it nudges me toward consistency and cleaner code. It’s like a coach reminding me to fix my form before I hurt myself. On the other hand, ESLint feels finicky and outdated. Terminal and PowerShell setups are archaic compared to the polished UI experiences we get with GitHub and other modern tools. I wish it was faster, more seamless, and less prone to strange setup quirks.

Still, even with the friction, I can’t deny its usefulness. It catches problems early, and that saves me from painful debugging later.

## When Standards Help and Hurt

Standards have saved me more than once—but they’ve also burned me. In Java, for example, a single misplaced symbol can break an entire project. That’s where the rigidity of standards feels unforgiving. At the same time, those same rules are what keep projects from spinning out of control. Coding standards really are both rigid and fluid at once: rigid in enforcing certain rules, but fluid in how they allow personal style within those boundaries.

I’ve seen this tension in group work too. In ICS 212, we sometimes had to switch computers and continue another person’s program. The shock of stepping into someone else’s coding style was overwhelming. Standards can’t erase every difference in thinking, but they at least make the experience less chaotic.

## The Evolution of Standards

Standards can’t stay frozen. Languages evolve, tools evolve, and teams evolve. I think coding standards need to change over time to reflect those shifts. In an ideal world, maybe we’d all code in one universal language—something simple, elegant, and consistent. That would be amazing, like a “New Heaven” for software developers. But the reality is that every language has its purpose, just like real-world languages. Standards evolve to keep that diversity usable rather than overwhelming.

## Closing Thoughts

Coding standards are friction in foundation. They slow you down in the moment—whether through lint errors or syntax rules—but they create the stability that lets projects last. They help you learn a language, even as they frustrate you with its quirks. They make collaboration possible, even though they can’t fully bridge the gap between individual coding styles.  

For me, the takeaway is clear: standards may bite, but without them, the whole structure collapses.  

---

I did use ChatGPT while reflecting on my experiences and shaping this essay. The AI helped me organize and polish my writing, but the ideas, examples, and voice are my own.
