---
layout: essay
type: essay
title: "Friction in Foundation"
# All dates must be YYYY-MM-DD format!
date: 2025-09-23
published: true
labels:
  - Coding
  - ESLint
  - Standards
---

# Friction in Foundation

If code is a building, then coding standards are the foundation. Without a foundation, a building might stand for a little while, but it will collapse once people start adding weight to it. Software projects work the same way. The bigger the project, the more people touch it, and the more fragile it becomes without shared rules. To me, coding standards aren't just helpful but I say that they actually define a language. They give you something to hold on to, a grammar that makes sense of the syntax.

This is why I agree with the idea that coding standards are vital for software development. They’re the structure that makes code reliable, shareable, and easier to learn.

So, after a week with ESLint in VSCode, I have mixed feelings. On the one hand, it’s useful. When it works, it nudges me toward consistency and cleaner code. It’s like a personal trainer in the gym that helps me with my form. On the other hand, ESLint feels finicky and outdated. Terminal and PowerShell setups are archaic compared to the polished UI we get with GitHub and other modern tools. I wish it was faster, more seamless, and less prone to strange setup stuff.

Still, even with the friction, I can’t deny its usefulness. It catches problems early, and that saves me from painful debugging later.

Standards have saved me more than once but they have also bitten me in the butt. In Java, for example, a single misplaced character or symbol can break an entire project. That’s where the rigidity of standards feels unforgiving. At the same time, those same rules are what keep projects from spinning out of control. Coding standards really are both rigid and fluid at once: rigid in enforcing certain rules, but fluid in how they allow personal style within those boundaries.

I’ve seen this tension in group work too. In ICS 212, we sometimes had to switch computers and continue another person’s program. The shock of stepping into someone else’s coding style was very overwhelming. Standards can’t erase every difference in thinking, but they at least make the experience a little less chaotic.

Standards can’t stay frozen. Languages evolve, tools evolve, and teams evolve. I think coding standards need to change over time to reflect those shifts. In an ideal world (maybe in like New Heaven or something), maybe we’d all code in one universal language. Something simple, elegant, and consistent. But the reality is that every language has its purpose, just like real-world languages. Standards evolve to keep that diversity usable rather than overwhelming.

Coding standards are friction in foundation. They slow you down in the moment—whether through lint errors or syntax rules—but they create the stability that lets projects last. They help you learn a language, even as they frustrate you. They make collaboration possible, even though they can’t fully bridge the gap between individual coding styles.  

Standards kinda suck but if you don't have them, you're building on a foundation of sand. 

---

I did use ChatGPT while reflecting on my experiences and shaping this essay. The AI helped me organize and polish my writing, but the ideas, examples, and voice are my own.
